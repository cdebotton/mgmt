// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['backbone', 'underscore', 'ns', 'relational', 'models/pivot'], function(Backbone, _, namespace) {
    namespace('BU.Model.Task');
    BU.Model.Task = (function(_super) {

      __extends(Task, _super);

      function Task() {
        this.parse = __bind(this.parse, this);
        return Task.__super__.constructor.apply(this, arguments);
      }

      Task.prototype.relations = [
        {
          type: Backbone.HasOne,
          relatedModel: BU.Model.Pivot,
          key: 'pivot',
          reverseRelation: {
            includeInJSON: 'id',
            key: 'task'
          }
        }
      ];

      Task.prototype.defaults = {
        start_date: new Date,
        end_date: new Date,
        color: 'blue'
      };

      Task.prototype.initialize = function() {
        this.on('change:start_date', this.adjustDate, this);
        this.on('change:end_date', this.adjustDate, this);
        this.on('change:track', this.fixTrack, this);
        this.on('change:developer_id', this.locateTrack, this);
        return this.fixTrack();
      };

      Task.prototype.findConflicts = function(attrs, status) {
        var conflicts, _ref;
        return conflicts = (_ref = this.get('user')) != null ? _ref.get('tasks').filter(function(task) {
          var _ref1, _ref2, _ref3, _ref4;
          return task.get('id') !== attrs.id && task.get('track') === attrs.track && (((task.get('start_date') < (_ref1 = attrs.start_date) && _ref1 < task.get('end_date'))) || ((task.get('start_date') < (_ref2 = attrs.end_date) && _ref2 < task.get('end_date')) || ((attrs.start_date < (_ref3 = task.get('start_date')) && _ref3 < attrs.end_date)) || ((attrs.start_date < (_ref4 = task.get('end_date')) && _ref4 < attrs.end_date)) || task.get('start_date').toString() === attrs.start_date.toString()) || task.get('end_date').toString() === attrs.end_date.toString());
        }) : void 0;
      };

      Task.prototype.validate = function(attrs, status) {
        var conflicts;
        conflicts = this.findConflicts(attrs, status);
        if ((conflicts != null ? conflicts.length : void 0) > 0) {
          return 'Collision conflict.';
        }
        if (attrs.track < 0) {
          return 'Track error.';
        }
      };

      Task.prototype.adjustDate = function(model, value, status) {
        var changed, date, key, _ref, _results;
        _ref = status.changes;
        _results = [];
        for (key in _ref) {
          changed = _ref[key];
          if (changed === true) {
            date = this.get(key);
            if (date instanceof Date) {
              date.setHours('00');
              date.setMinutes('00');
              _results.push(this.attributes[key] = date);
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      Task.prototype.fixTrack = function() {
        return this.set('track', parseInt(this.get('track')));
      };

      Task.prototype.url = function() {
        return "/admin/api/v1/tasks" + (!this.isNew() ? "/update/" + (this.get('id')) : '');
      };

      Task.prototype.parse = function() {
        var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        if ((_ref = this.attributes) != null) {
          _ref['start_date'] = new Date((_ref1 = this.attributes) != null ? _ref1['start_date'] : void 0);
        }
        if ((_ref2 = this.attributes) != null) {
          _ref2['start_date'].setHours(0);
        }
        if ((_ref3 = this.attributes) != null) {
          _ref3['start_date'].setMinutes(0);
        }
        if ((_ref4 = this.attributes) != null) {
          _ref4['start_date'].setSeconds(0);
        }
        if ((_ref5 = this.attributes) != null) {
          _ref5['end_date'] = new Date((_ref6 = this.attributes) != null ? _ref6['end_date'] : void 0);
        }
        if ((_ref7 = this.attributes) != null) {
          _ref7['end_date'].setHours(0);
        }
        if ((_ref8 = this.attributes) != null) {
          _ref8['end_date'].setMinutes(0);
        }
        return (_ref9 = this.attributes) != null ? _ref9['end_date'].setSeconds(0) : void 0;
      };

      Task.prototype.locateTrack = function() {
        var conflicts, fakeAttrs, track, _ref;
        this.set('user', this.get('developer_id'));
        track = 0;
        conflicts = true;
        while (conflicts === true && track < 10) {
          fakeAttrs = _.extend({}, this.attributes, {
            track: track
          });
          if ((conflicts = ((_ref = this.findConflicts(fakeAttrs)) != null ? _ref.length : void 0) > 0)) {
            track++;
          }
        }
        return this.set('track', track);
      };

      return Task;

    })(Backbone.RelationalModel);
    return BU.Model.Task.setup();
  });

}).call(this);

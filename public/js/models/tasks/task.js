// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['backbone', 'underscore', 'ns', 'relational'], function(Backbone, _, ns) {
    var n, t;
    t = new Date();
    n = new Date();
    n.setDate(n.getDate() + 14);
    t.setHours(0, 0, 0, 0);
    n.setHours(0, 0, 0, 0);
    ns('United.Models.Tasks.Task');
    United.Models.Tasks.Task = (function(_super) {

      __extends(Task, _super);

      function Task() {
        return Task.__super__.constructor.apply(this, arguments);
      }

      Task.prototype.defaults = {
        name: 'New Task',
        start_date: t,
        end_date: n,
        color: null,
        author_id: window.author_id,
        percentage: 0
      };

      Task.prototype.url = function() {
        return "/api/v1/schedules" + (!this.isNew() ? "/" + (this.get('id')) : '');
      };

      Task.prototype.initialize = function() {
        this.on('change:user', this.locateTrack, this);
        if (!!this.isNew()) {
          return this.locateTrack();
        }
      };

      Task.prototype.findConflicts = function(attrs, status) {
        var conflicts, _ref, _ref1,
          _this = this;
        return conflicts = typeof this.get === "function" ? (_ref = this.get('user')) != null ? typeof _ref.get === "function" ? (_ref1 = _ref.get('tasks')) != null ? _ref1.filter(function(task) {
          var adjacent, crash, endpoint, foreign, startpoint, taskend, taskstart;
          startpoint = attrs.start_date;
          endpoint = attrs.end_date;
          taskstart = task.get('start_date');
          taskend = task.get('end_date');
          foreign = task.cid !== _this.cid;
          adjacent = +task.get('track') === +attrs.track;
          crash = (startpoint < taskend) && (endpoint > taskstart);
          return foreign && adjacent && crash;
        }) : void 0 : void 0 : void 0 : void 0;
      };

      Task.prototype.validate = function(attrs, status) {
        var conflicts;
        if ((status != null ? status.silent : void 0) !== true) {
          conflicts = this.findConflicts(attrs, status);
          if ((conflicts != null ? conflicts.length : void 0) > 0) {
            return 'Collision conflict.';
          }
          if (attrs.track < 0) {
            return 'Track error.';
          }
        }
      };

      Task.prototype.parse = function(resp) {
        var parts;
        if (resp.start_date && (parts = resp.start_date.match(/(\d{4})-(\d{2})-(\d{2})/))) {
          resp.start_date = new Date(parts[1], parseInt(parts[2]) - 1, parts[3], 0, 0, 0, 0);
        }
        if (resp.end_date && (parts = resp.end_date.match(/(\d{4})-(\d{2})-(\d{2})/))) {
          resp.end_date = new Date(parts[1], parseInt(parts[2]) - 1, parts[3], 0, 0, 0, 0);
        }
        resp.track = parseInt(resp.track);
        return resp;
      };

      Task.prototype.locateTrack = function() {
        var conflicts, fakeAttrs, track, _ref;
        track = 0;
        conflicts = true;
        while (conflicts === true && track < 1000) {
          fakeAttrs = _.extend({}, this.attributes, {
            track: track
          });
          if ((conflicts = ((_ref = this.findConflicts(fakeAttrs)) != null ? _ref.length : void 0) > 0)) {
            track++;
          }
        }
        this.set('track', track);
        return this;
      };

      Task.prototype.comparator = function(task) {
        return task.get('start_date');
      };

      return Task;

    })(Backbone.RelationalModel);
    return United.Models.Tasks.Task.setup();
  });

}).call(this);

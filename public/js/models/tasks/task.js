// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['backbone', 'underscore', 'ns', 'relational'], function(Backbone, _, ns) {
    var d, n, t;
    d = new Date();
    t = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
    n = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
    n.setDate(n.getDate() + 14);
    n.setHours(0);
    n.setMinutes(0);
    n.setSeconds(0);
    n.setMilliseconds(0);
    ns('United.Models.Tasks.Task');
    United.Models.Tasks.Task = (function(_super) {

      __extends(Task, _super);

      function Task() {
        this.parse = __bind(this.parse, this);
        return Task.__super__.constructor.apply(this, arguments);
      }

      Task.prototype.defaults = {
        name: 'New Task',
        start_date: t,
        end_date: n,
        color: null,
        author_id: window.author_id,
        percentage: 0
      };

      Task.prototype.url = function() {
        return "/api/v1/schedules" + (!this.isNew() ? "/update/" + (this.get('id')) : '');
      };

      Task.prototype.initialize = function() {
        this.on('change:user', this.locateTrack, this);
        if (!!this.isNew()) {
          return this.locateTrack();
        }
      };

      Task.prototype.findConflicts = function(attrs, status) {
        var conflicts, _ref, _ref1,
          _this = this;
        return conflicts = typeof this.get === "function" ? (_ref = this.get('user')) != null ? typeof _ref.get === "function" ? (_ref1 = _ref.get('tasks')) != null ? _ref1.filter(function(task) {
          var adjacent, crash, endpoint, foreign, startpoint, taskend, taskstart;
          startpoint = attrs.start_date;
          endpoint = attrs.end_date;
          taskstart = task.get('start_date');
          taskend = task.get('end_date');
          foreign = task.cid !== _this.cid;
          adjacent = +task.get('track') === +attrs.track;
          crash = (startpoint < taskend) && (endpoint > taskstart);
          return foreign && adjacent && crash;
        }) : void 0 : void 0 : void 0 : void 0;
      };

      Task.prototype.validate = function(attrs, status) {
        var conflicts;
        if ((status != null ? status.silent : void 0) !== true) {
          conflicts = this.findConflicts(attrs, status);
          if ((conflicts != null ? conflicts.length : void 0) > 0) {
            return 'Collision conflict.';
          }
          if (attrs.track < 0) {
            return 'Track error.';
          }
        }
      };

      Task.prototype.parse = function() {
        var _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        if ((_ref = this.attributes) != null) {
          _ref['start_date'] = new Date((_ref1 = this.attributes) != null ? _ref1['start_date'] : void 0);
        }
        if ((_ref2 = this.attributes) != null) {
          _ref2['start_date'].setHours(0);
        }
        if ((_ref3 = this.attributes) != null) {
          _ref3['start_date'].setMinutes(0);
        }
        if ((_ref4 = this.attributes) != null) {
          _ref4['start_date'].setSeconds(0);
        }
        if ((_ref5 = this.attributes) != null) {
          _ref5['end_date'] = new Date((_ref6 = this.attributes) != null ? _ref6['end_date'] : void 0);
        }
        if ((_ref7 = this.attributes) != null) {
          _ref7['end_date'].setHours(0);
        }
        if ((_ref8 = this.attributes) != null) {
          _ref8['end_date'].setMinutes(0);
        }
        if ((_ref9 = this.attributes) != null) {
          _ref9['end_date'].setSeconds(0);
        }
        return (_ref10 = this.attributes) != null ? _ref10['track'] = parseInt(this.attributes['track']) : void 0;
      };

      Task.prototype.locateTrack = function() {
        var conflicts, fakeAttrs, track, _ref;
        track = 0;
        conflicts = true;
        while (conflicts === true && track < 1000) {
          fakeAttrs = _.extend({}, this.attributes, {
            track: track
          });
          if ((conflicts = ((_ref = this.findConflicts(fakeAttrs)) != null ? _ref.length : void 0) > 0)) {
            track++;
          }
        }
        this.set('track', track);
        return this;
      };

      Task.prototype.comparator = function(task) {
        return task.get('start_date');
      };

      return Task;

    })(Backbone.RelationalModel);
    return United.Models.Tasks.Task.setup();
  });

}).call(this);
